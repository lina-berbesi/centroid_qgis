

suppressPackageStartupMessages(library("sf"))
suppressPackageStartupMessages(library("dplyr"))
suppressPackageStartupMessages(library("spgwr"))
suppressPackageStartupMessages(library("proj4"))
suppressPackageStartupMessages(library("ggplot2"))


# Load stations metadata location

proj4 <- "+proj=tmerc +lat_0=0 +lon_0=173 +k=0.9996 +x_0=1600000 +y_0=10000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs "

stations_metadata_locations_tmp<-read.csv("analysis/20230919_electricity_data_module/substations_location/stations_location_metadata_geocoded.csv")

stations_metadata_locations<-stations_metadata_locations_tmp %>% 
                             select(NSP,"POC.code","Network.participant","NZTM.easting.final","NZTM.northing.final") %>% 
                             mutate(row=row_number())

# Find duplicated in the stations metadata location

stations_metadata_locations %>% 
   filter(duplicated(paste0('NZTM.easting','NZTM.northing')) | duplicated(paste0('NZTM.easting','NZTM.northing'),fromLast=TRUE)) %>% 
   summarize(duplicated_stations_location=n())

# From the source data extract the x, y coordinates of the UTM

x_y <- stations_metadata_locations %>% 
  dplyr::select('NZTM.easting','NZTM.northing')


# Transform the data

lon_lat <- proj4::project(x_y, proj4, inverse = TRUE) 


# Convert to a data frame

lon_lat2 <- data.frame(Longitude = lon_lat$x, Latitude = lon_lat$y) %>% 
                                    mutate(row=row_number())


# Add to the original file

stations_metadata_locations2 <- stations_metadata_locations %>%
  left_join(y=lon_lat2,by=c("row"="row")) 

# Missing TA values 

stations_metadata_locations2   %>% filter(is.na(Longitude) | is.na(Latitude)) %>% summarize(tot=n())
stations_metadata_locations2  %>% filter(is.na(Longitude) | is.na(Latitude)) %>% summarize(tot=n())/ stations_metadata_locations2  %>% summarize(tot=n()) # 15%

# Convert location metadata data frame to a spatial data frame - removing missing coordinates because they don't allow the conversion

stations_metadata_locations3<-stations_metadata_locations2 %>% filter(!is.na(Longitude) & !is.na(Latitude)) 

# Load TA polygons shapefile

ta_polygons<-sf::read_sf("analysis/20230919_electricity_data_module/statsnz-territorial-authority-2023-clipped-generalised-SHP/territorial-authority-2023-clipped-generalised.shp") %>% 
  select(-c("LAND_AREA_","AREA_SQ_KM","Shape_Leng","TA2023_V_2"))

# Load Higher Geographies csv

higher_geographies_concordance_tmp<-read.csv("analysis/20230919_electricity_data_module/statsnz-meshblock-higher-geographies-2023-generalised-CSV/meshblock-higher-geographies-2023-generalised.csv")

higher_geographies_concordance<- higher_geographies_concordance_tmp %>%  
                                 select("TA2023_V1_00","REGC2023_V1_00","REGC2023_V1_00_NAME") %>% 
                                 unique() %>% 
                                 filter(TA2023_V1_00!=999 & !duplicated(TA2023_V1_00))


# Define the Stations as points(pts) to perform the Point in Polygon Analysis

pts <- sf::st_as_sf(stations_metadata_locations3, coords = c("Longitude", "Latitude"), crs = 4326) %>%
       left_join(stations_metadata_locations3[,c("row","Longitude","Latitude")],by="row")

# Define the TAs as polygons to perform the Point in Polygon Analysis

p <- sf::st_as_sf(ta_polygons)  

# Make sure polygons and location metadata have the same coordinate reference system

crs_poly<-sf::st_crs(p)
pts <- sf::st_transform(pts, crs = crs_poly)
p <- sf::st_transform(p, crs = crs_poly)

#  Perform the Point in Polygon analysis using the Intersect function

pts_index_ta_tmp <- sf::st_intersection(pts, p) %>% st_drop_geometry()


# Adding Regional Council Information just for comparison purposes

pts_index_ta<-pts_index_ta %>% 
                    mutate(TA2023_V1_00=as.numeric(TA2023_V1_ )) %>%
                    left_join(higher_geographies_concordance,by="TA2023_V1_00",relationship="many-to-many")


View(pts_index_ta_rc)
nrow(pts_index_ta)
nrow(pts_index_ta_rc)


# Reading consumption data file generated by the Markets team

consumption_rds<-readRDS("analysis/20230919_electricity_data_module/markets_data/monthly_gxp_demand.rds") %>%
                 mutate(Year=as.numeric(format(TimePeriod, "%Y")))


# Joining stations metadata location data to the consumption data

consumption_ta_allocated<-consumption_rds %>% 
                        left_join(pts_index_ta,by=c("POC"="POC.code"),relationship="many-to-many") %>%
                        select(-c("row","TA2023_V_1","TA2023_V1_00","REGC2023_V1_00_NAME"))

consumption_ta_aggregated<-consumption_ta_allocated %>% group_by(Year,TA2023_V1_) %>% 
                             summarize(ta_tot=sum(Value,na.rm=TRUE))  


# Plotting electricity consumption data after 2019
# Some TAs will show up as missing since there are no stations


consumption_ta_map<-ta_polygons %>% left_join(consumption_ta_aggregated, by = "TA2023_V1_") %>% arrange("TA2023_V1_") %>% 
  filter(!is.na(Year) & Year>2019)

ggplot(consumption_ta_map) + geom_sf(aes(fill = ta_tot),size=0.3) + facet_wrap(~ Year) + scale_fill_continuous(name = 'Energy KWh')










# Notes from previous meeting with the Markets team on the 19th of September:
#  - Regional gas emissions come from StatsNz
#  - Electricity module should include consumption, generation by source(solar, wind, coal, geo-thermal) and total generation
#  - There is the need to specify it will not include self-generation data (some sub-station go to specific users - say Fonterra)
#  - We need to display not only consumption and generation by total but also per capita
#  - Environment module(Niwa rain) could be included but it is currently out of scope for first iteration of electricity module



